# Тестовое задание для StreamEnergy

<details>
  <summary>Задание</summary>
  
Тестовое задание: Описание: Разработайте асинхронное веб-приложение на основе FastAPI, которое предоставляет сервис по управлению личными заметками и включает в себя следующие компоненты:

1. Управление заметками: Реализуйте CRUD операции для заметок. Каждая заметка должна содержать: идентификатор, заголовок, содержимое, теги, дату создания и дату последнего изменения. Предусмотрите возможность добавления нескольких тегов к одной заметке и поиска заметок по тегам. Данные должны храниться в базе данных PostgreSQL/MySQL взаимодействие через SQLAlchemy.

2. Аутентификация и авторизация: Реализуйте регистрацию и аутентификацию пользователей с использованием JWT-токенов. Пользователь может управлять только своими заметками. Пароли должны храниться в зашифрованном виде (используйте подходящий алгоритм хеширования).

3. Telegram-бот: Создайте асинхронного Telegram-бота с использованием aiogram, который предоставляет следующие функции: Авторизация пользователя через Telegram (связь аккаунтов). Получение списка заметок. Создание новой заметки. Поиск заметок по тегам. Бот должен взаимодействовать с вашим API.

4. Docker контейнеризация: Поместите проект в докер контейнер Все сервисы (FastAPI приложение, БД, Telegram-бот) должны запускаться и взаимодействовать в контейнерах.

5. Логирование и обработка ошибок: Реализуйте централизованное логирование действий пользователей и ошибок приложения. Логи должны сохраняться в файлы с ротацией по дате. Обеспечьте обработку возможных исключений и ошибок с возвратом информативных сообщений пользователю.

6. Безопасность: Настройте ограничение количества запросов (rate limiting) для API и бота. Обеспечьте валидацию вводимых данных как на стороне клиента, так и на стороне сервера.

7. Дополнительное задание (по желанию): Напишите unit-тесты для основных частей приложения, используя pytest или аналогичный инструмент. Реализуйте веб-интерфейс для работы с заметками, используя FastAPI и шаблонизатор Jinja2.
  
</details>

# Запуск приложения
(примечание: программа запускалась и тестировалась на Windows 11)

(примечание 2: для запуска можно использовать Make файл, его команды будут указаны в скобках)


Для запуска необходимо выполнить команду
```
	docker-compose up --build -d
```
![containers in docker](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/docker_run.png)

После чего нужно вызвать Alembic для выполнения автоматиизированных миграций:
```
docker-compose exec fastapi-app alembic revision --autogenerate -m "init migration"
docker-compose exec fastapi-app alembic upgrade head
```
![alembic](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/alembic.png)
Убедимся что сервер запущен и работает:
![hello world](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/helloworld.png)

# Пользователи
Для работы с пользователями была выбрана библиотека [fastapi-users](https://fastapi-users.github.io/), которая автоматизирует многие стандартные процессы вроде регистрации и аутентификации. Также она предлагает готовое решение и для работы с JWT, в качестве транспорта выбран способ носитель Bearer. Для простейшей демонатрции работы воспользуемся программой Postman.

Регистрация пользователя:
![user_reg](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/user_reg.png)

Аутентификация и получения Access Token:
![login](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/login.png)

Проверка эндпоинтов, требующих авторизации. Отправка запроса без токена:
![unauthorizied](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/unauthorizied.png)


Теперь попробуем зайти на этот же эндпоинт с помощью токена:
![auth_endpoint](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/auth_endpoint.png)

## Rate Limiter
Не стоит злоупотреблять многочисленными запросами, на сервере установлен Rate Limiter:
![rate_limiter](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/rate_limiter.png)
Для этих целей была выбрана библиотека [slowapi](https://github.com/laurentS/slowapi), лимитер работает как мидлвара и ему нужно указать, какие именно хэндлеры он должен отслеживать

## Telegram Bot
Разработан [телеграм бот](https://t.me/stream_energy_test_bot ) на основе библиотеки aiogram (v3). Перед использованием бот попросит вас указать почту, уже зарегистрированную в приложении, чтобы связать аккаунт в БД с телеграм акаунтом. На этом этапе есть валидация введенного имэйл адреса:
![link_accounts](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/link_accounts.png)

Пробуем добавить заметку. Здесь бот проверяет корректность тегов, они могут содержать только буквы и цифры:
![add_note](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/add_note.png)

Пробуем поискать заметки по введенным ранее тегам к ним:
![search_note](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/search_note.png)

## Логгер
Для логирования была выбрана библиотека [loguru](https://github.com/Delgan/loguru), настроенная таким образом, чтобы писать логи в файл и в консоль:
![logs](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/logs.png)
Проверим работоспособность логгера вручную:
![log_test](https://github.com/he1lhamster/streamEnergy_test/blob/main/images/log_test.png)

## Валидация данных
За валидацию данных, полученных от пользователя и отправленных сервером отвечает Pydantic, плотно сплетенный с самим фреймворком FastAPI. В хэндлерах используются схемы данных для обмениваемых объектов.

# Проблемы, трудности и перспективы
Большим вопросом была связь ТГ аккаунта и аккаунта в базе данных. Стандартная инъекция зависимости не может проверить авторизован ли текущий пользователь телеграма при запросах, поскольку он не пользуется JWT токеном. Возможно, можно как-то валидировать, что данные приходят именно из телеграм бота, а не с третьей стороны.

Тестирование пользователей и CRUD для заметок возможно реализовать через Postman сценарии. 

Возможно добавить веб-интерфейс с помощью шаблонизатора Jinja2 и JavaScript для более комфортной работы пользователя с приложением.
